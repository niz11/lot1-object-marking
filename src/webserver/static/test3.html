<!doctype html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>Hello WebXR!</title>

    <!-- three.js -->
    <script src="new/three.js"></script>
    <script src="new/GLTFLoader.js"></script>

    <script src="new/EventDispatcher.js"></script>

    <script src="jsartoolkit5/artoolkit.min.js"></script>
    <script src="jsartoolkit5/artoolkit.api.js"></script>
    <!-- include threex.artoolkit -->
    <script src="threex/threex-artoolkitsource.js"></script>
    <script src="threex/threex-artoolkitcontext.js"></script>
    <script src="threex/threex-arbasecontrols.js"></script>
    <script src="threex/threex-armarkercontrols.js"></script>
</head>
<style>
    button.p{
        display: block;
        width: 20px;
        height: 20px;
        border-radius: 10px;
        border: none;
        background-color: #008CBA;
        box-sizing: border-box;
        visibility: visible;
        position: fixed;
    }

    /*button[slot="hotspot-hand"]{*/
    /*    --min-hotspot-opacity: 0;*/
    /*    background-color: red;*/
    /*}*/
    div.con {
        /*background-color: rgba(127, 127, 127, 0.90);*/
        /*position: relative;*/
        position: fixed;
        top: 50%;
        left: 50%;
        margin-top: -50px; /* Negative half of height. */
        margin-left: -50px; /* Negative half of width. */

        /*min-height: 100vh;*/
        /*visibility: hidden;*/
    }
    div.cen {
        /*background-color: rgba(127, 127, 127, 0.90);*/
        /*position: relative;*/
        width: 100px;
        height: 100px;
        vertical-align: middle;
        text-align: center;
        display: table-cell;
    }
    div.foot {
        background-color: rgba(0, 0, 0, 0.30);
        color: rgb(255,255,255);
        bottom: 0;
        left: 0;
        position: fixed;
        /*padding: 1em;*/
        text-align: center;
        width: 100%;
        /*visibility: collapse;*/
    }
    #annotation{
        background-color: #888888;
        position: absolute;
        transform: translate(10px, 10px);
        border-radius: 10px;
        padding: 10px;
    }
    /* This keeps child nodes hidden while the element loads */
    :not(:defined) > * {
        display: none;
    }
</style>
<body>
<div id="infoBox">
    <button class="p" data-position="-0.12 0.0 0.0">
    </button>

    <div class="con" id = "con">
        <div class="cen">
            +
        </div>
    </div>

    <div class="foot">
        <div id="ax"></div>
        <div id="ay"></div>
        <div id="az"></div>

        <div id="bx"></div>
        <div id="by"></div>
        <div id="bz"></div>

        <div id="rx">Instructions:</div>
        <div id="ry">    1. Look around with the camera around the artwork for better AR tracking</div>
        <div id="rz">    2. Point the camera to the middle of the marker until the box is green </div>
    </div>

</div>
<!-- Starting an immersive WebXR session requires user interaction.
We start this one with a simple button. -->
<button onclick="activateXR()" >Start Hello WebXR</button>
<!-- <script type="module">
    import {WebXRButton} from './webxr-button.js';


</script> -->
<script>

    let objAnchor = null;


    let markerOrientationS = [];
    let viewOrientationS = []; //TODO: REMOVE

    let markerOrientationS2 = []; //TODO: REMOVE
    let viewOrientationS2 = []; //TODO: REMOVE


    let va, vb, vc, vd; //TODO: REMOVE

    let euler; //TODO: REMOVE


    vd = 0;


    // Add a canvas element and initialize a WebGL context that is compatible with WebXR.
    const canvas = document.createElement("canvas");
    document.body.appendChild(canvas);
    const gl = canvas.getContext("webgl2", { xrCompatible: true });










    var arJSScene, arJSScamera, arJSScamera2, arJSSmesh, arJSSmarkerControls;
    var arToolkitSource, arToolkitContext;

    var mx, my, mz;

    var firstUpdate = false;

    initialize();

    const arjsBuffer = gl.createFramebuffer();


    let fCounter = 0;
    let box = null;

    let arjsW = 0;
    let arjsH = 0;
    const arjsBuffer2 = gl.createFramebuffer();

    const scene = new THREE.Scene();

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
    directionalLight.position.set(10, 15, 10);
    scene.add(directionalLight);

    async function activateXR() {
        // Set up the WebGLRenderer, which handles rendering to the session's base layer.
        const renderer = new THREE.WebGLRenderer({
            alpha: true,
            preserveDrawingBuffer: true,
            canvas: canvas,
            context: gl
        });
        renderer.autoClear = false;

        const camera = new THREE.PerspectiveCamera();
        camera.matrixAutoUpdate = false;
        let uiElement = document.getElementById('infoBox');
        let content = document.getElementById('con');
        content.style.visibility = 'visible';
        // content.style.minHeight = '100vh';
        // content.style.minHeight = '100hw';
        const session = await navigator.xr.requestSession("immersive-ar", { requiredFeatures: ['hit-test', 'anchors', 'camera-access', 'plane-detection'],
            optionalFeatures: ['dom-overlay'], domOverlay: { root: uiElement } });
        session.updateRenderState({
            baseLayer: new XRWebGLLayer(session, gl)
        });


        let raycaster = new THREE.Raycaster();

        box = new THREE.Mesh(
            new THREE.BoxGeometry(0.1, 0.24, 0.15),
            new THREE.MeshBasicMaterial({color: 0x0000ff}) //blue
        );
        box.visible = false;
        box.material.wireframe = true;
        scene.add(box);






        const referenceSpace = await session.requestReferenceSpace('local');
        const viewerSpace = await session.requestReferenceSpace('viewer');
        const hitTestSource = await session.requestHitTestSource({
            space: viewerSpace,
            entityTypes : ["plane", "point"],
        });
        const loader = new THREE.GLTFLoader();
        let reticle;
        loader.load("https://immersive-web.github.io/webxr-samples/media/gltf/reticle/reticle.gltf", function (gltf) {
            reticle = gltf.scene;
            reticle.visible = false;
            scene.add(reticle);
        });

        let flower;
        loader.load("https://immersive-web.github.io/webxr-samples/media/gltf/sunflower/sunflower.gltf", function (gltf) {
            flower = gltf.scene;
        });


        let glBinding = new XRWebGLBinding(session, gl);

        // Create a render loop that allows us to draw on the AR view.
        const onXRFrame = (time, frame) => {




            // Retrieve the pose of the device.
            // XRFrame.getViewerPose can return null while the session attempts to establish tracking.

            const poseV = frame.getViewerPose(viewerSpace);
            const pose = frame.getViewerPose(referenceSpace);
            if (pose) {
                const view = pose.views[0];
                const viewport = session.renderState.baseLayer.getViewport(view);

                if (!objAnchor){

                    let tex = glBinding.getCameraImage(frame, view);




                    //TODO: try PBO's to enhance performance
                    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, arjsBuffer);
                    gl.framebufferTexture2D(
                        gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
                        gl.TEXTURE_2D, tex, 0);

                    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, arjsBuffer2);
                    gl.blitFramebuffer(0, 0, viewport.width, viewport.height, 0, 0, arjsW, arjsH, gl.COLOR_BUFFER_BIT, gl.NEAREST);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, arjsBuffer2);

                    let data = new Uint8ClampedArray(arjsW * arjsH * 4);
                    gl.readPixels(0, 0, arjsW, arjsH, gl.RGBA, gl.UNSIGNED_BYTE, data);

                    arToolkitContext.update(data);
                }


                gl.bindFramebuffer(gl.FRAMEBUFFER, session.renderState.baseLayer.framebuffer);

                // const viewport = session.renderState.baseLayer.getViewport(view);
                renderer.setSize(viewport.width, viewport.height);

                // Use the view's transform matrix and projection matrix to configure the THREE.camera.
                camera.matrix.fromArray(view.transform.matrix);
                camera.projectionMatrix.fromArray(view.projectionMatrix);
                camera.updateMatrixWorld(true);

                let offset = 100;

                // camera.matrix.decompose(camera.position, camera.quaternion, camera.scale)

                vd += 0.01;


                if (!objAnchor && arJSSmarkerControls.object3d.visible) {
                    let pos = arJSSmarkerControls.object3d.position;
                    let cpos = new THREE.Vector3(pos.x, pos.y, pos.z).project(arJSScamera2);


                    // document.getElementById('rx').innerHTML = 'x: ' + arJSSmarkerControls.object3d.rotation.x;
                    // document.getElementById('ry').innerHTML = 'y: ' + arJSSmarkerControls.object3d.rotation.y;
                    // document.getElementById('rz').innerHTML = 'z: ' + arJSSmarkerControls.object3d.rotation.z;


                    arJSSmesh.position.x = cpos.x * viewport.width / 2.0;
                    arJSSmesh.position.y = cpos.y * viewport.height / -2.0;
                    if (arJSScamera.right !== viewport.width / 2.0){
                        arJSScamera.left = -viewport.width / 2.0;
                        arJSScamera.right = viewport.width / 2.0;
                        arJSScamera.top = viewport.height  / 2.0;
                        arJSScamera.bottom = -viewport.height  / 2.0;
                        arJSScamera.updateProjectionMatrix();
                        console.log("Updating Projection Matrix!")
                    }

                    arJSSmesh.position.z = 4.0;

                    arJSSmesh.rotation.z = Math.PI - arJSSmarkerControls.object3d.rotation.z;

                    mx.rotation.z = arJSSmarkerControls.object3d.rotation.x;
                    my.rotation.z = arJSSmarkerControls.object3d.rotation.y;
                    mz.rotation.z = arJSSmarkerControls.object3d.rotation.z;

                    const ratio = viewport.width / viewport.height;

                    offset = cpos.x * cpos.x * ratio + cpos.y * cpos.y / ratio ;
                    if (offset < 0.004)  arJSSmesh.material.color.setRGB(0.0, 1.0, 0.0);
                    else arJSSmesh.material.color.setRGB(1.0, 0.0, 0.0);

                    renderer.render(arJSScene, arJSScamera);
                }


                // const pv = frame.getPose(viewerSpace, referenceSpace);
                // const pv = view;
                // const pv = frame.getPose(referenceSpace, viewerSpace);

                // box.position.set(pv.transform.position.x, pv.transform.position.y, pv.transform.position.z);
                // box.quaternion.fromArray([pv.transform.orientation.x, pv.transform.orientation.y,
                //     pv.transform.orientation.z, pv.transform.orientation.w])
                // box.translateZ(-0.5);
                // box.rotation.x = 0;
                // box.rotation.z = 0;

                const hitTestResults = !objAnchor ? frame.getHitTestResults(hitTestSource) : null;
                if (hitTestResults && hitTestResults.length > 0 && reticle) {
                    const hitPose = hitTestResults[0].getPose(referenceSpace);
                    const hitPoseV = hitTestResults[0].getPose(viewerSpace);
                    reticle.visible = true;

                    let vo = hitPoseV.transform.orientation;
                    euler = new THREE.Euler().setFromQuaternion(new THREE.Quaternion().fromArray([vo.x, vo.y, vo.z, vo.w]));

                    vo = hitPose.transform.orientation;
                    va = new THREE.Euler().setFromQuaternion(new THREE.Quaternion().fromArray([vo.x, vo.y, vo.z, vo.w]));

                    reticle.matrix.fromArray(hitPose.transform.matrix);
                    reticle.matrix.decompose(reticle.position, reticle.quaternion, reticle.scale);
                    // if (offset < 0.004) {
                    //     //TODO Remove
                    //
                    //     reticle.rotation.y += arJSSmesh.rotation.z;
                    // }

                    // box.position.set(hitPose.transform.position.x, hitPose.transform.position.y, hitPose.transform.position.z);
                    //
                    // box.lookAt(camera.position);
                    //
                    // const lx = box.rotation.x;
                    // const ly = box.rotation.y;
                    // const lz = box.rotation.z;
                    //
                    // // box.rotation.x = va.x;
                    // // box.rotation.z = va.z;
                    //
                    // document.getElementById('ax').innerHTML = 'ax: ' + (va.x / Math.PI * 180);
                    // document.getElementById('ay').innerHTML = 'ay: ' + (va.y / Math.PI * 180);
                    // document.getElementById('az').innerHTML = 'az: ' + (va.z / Math.PI * 180);
                    //
                    // document.getElementById('bx').innerHTML = 'bx: ' + (euler.x / Math.PI * 180);
                    // document.getElementById('by').innerHTML = 'by: ' + (euler.y / Math.PI * 180);
                    // document.getElementById('bz').innerHTML = 'bz: ' + (euler.z / Math.PI * 180);
                    //
                    // document.getElementById('rx').innerHTML = 'brx: ' + (box.rotation.x / Math.PI * 180);
                    // document.getElementById('ry').innerHTML = 'bry: ' + (box.rotation.y / Math.PI * 180);
                    // document.getElementById('rz').innerHTML = 'brz: ' + (box.rotation.z / Math.PI * 180);
                    //
                    // box.quaternion.fromArray([hitPose.transform.orientation.x, hitPose.transform.orientation.y,
                    //     hitPose.transform.orientation.z, hitPose.transform.orientation.w]);
                    //
                    // box.rotation.y = lz;






                    // box.rotation.y -= camera.rotation.y;
                    // box.rotation.y += arJSSmesh.rotation.y;



                    // box.rotation.y = 0;

                    // reticle.rotation.setFromQuaternion(new THREE.Quaternion().fromArray([hitPose.transform.orientation.x, hitPose.transform.orientation.y,
                    //     hitPose.transform.orientation.z, hitPose.transform.orientation.w]))

                    //
                    // reticle.updateMatrixWorld(true);


                    const maxCount = 21;

                    if (offset < 0.004 && fCounter < maxCount) {
                        fCounter += 1;
                        markerOrientationS.push({rotation: arJSSmesh.rotation, offset: offset});
                        const vo = view.transform.orientation;
                        viewOrientationS.push(new THREE.Euler().setFromQuaternion(new THREE.Quaternion().fromArray([vo.x, vo.y, vo.z, vo.w])));
                    }
                    else {
                        fCounter = 0;
                        markerOrientationS = [];
                        viewOrientationS = [];
                    }

                    if (fCounter >= maxCount) {

                        const vo = hitPose.transform.orientation;
                        va = new THREE.Euler().setFromQuaternion(new THREE.Quaternion().fromArray([vo.x, vo.y, vo.z, vo.w]));
                        //TODO: choose median
                        markerOrientationS2 = markerOrientationS;
                        viewOrientationS2 = viewOrientationS;
                        // console.log("HP ", hitPose.transform.position.x, hitPose.transform.position.y, hitPose.transform.position.z)
                        hitTestResults[0].createAnchor().then((anchor) => {
                            objAnchor = anchor;
                        }, (error) => {
                            console.error("Could not create anchor: " + error);
                        });
                        console.log("Created Anchor!")
                    }

                }



                const trackedAnchors = frame.trackedAnchors;

                if (objAnchor && !trackedAnchors.has(objAnchor)) {
                    // Handle anchor tracking loss - `anchor` was present
                    // in the previous frame but is no longer tracked.
                    objAnchor = null;
                    box.visible = false;
                    console.log("Lost anchor...")
                }

                if (objAnchor) {
                    // Query most recent pose of the anchor relative to some reference space:
                    const pose = frame.getPose(objAnchor.anchorSpace, referenceSpace);

                    const vo = pose.transform.orientation;
                    vb = new THREE.Euler().setFromQuaternion(new THREE.Quaternion().fromArray([vo.x, vo.y, vo.z, vo.w]));

                    box.visible = true;
                    box.matrix.fromArray(pose.transform.matrix);
                    box.matrix.decompose(box.position, box.quaternion, box.scale);

                    box.position.y += 0.075;


                    markerOrientationS2.sort((a, b)=>{return a.rotation.y > b.rotation.y ? 1 : -1;});

                    const rot = markerOrientationS2[Math.floor(markerOrientationS2.length / 2)];
                    //
                    console.log(rot);
                    box.rotation.y += rot.rotation.z ;

                    // box.quaternion.fromArray([pose.transform.orientation.x, pose.transform.orientation.y,
                    //     pose.transform.orientation.z, pose.transform.orientation.w])

                    // box.rotation = vb;



                    // box.rotation.y += markerOrientationS2[2].z

                    // box.position.set(pose.transform.position.x, pose.transform.position.y + 0.075, pose.transform.position.z);
                    // box.rotation.y = markerOrientationS2[2].z - viewOrientationS2[2].y;
                    // box.updateMatrixWorld(true);

                    // box.matrix.fromArray(pose.transform.matrix);

                    box.visible = true;

                    let elems = document.getElementsByClassName("p");


                    for(let e of elems) {
                        let dpe = e.getAttribute("data-position").split(" ");
                        let dpx = Number(dpe[0]) + box.position.x;
                        let dpy = Number(dpe[1]) + box.position.y;
                        let dpz = Number(dpe[2]) + box.position.z;

                        const dpv = new THREE.Vector3(dpx, dpy, dpz);
                        const sx = dpv.clone();

                        const wh = viewport.width / 2.0;
                        const hh = viewport.height / 2.0;

                        sx.project(camera);
                        // e.style.left = (wh * sx.x) + wh + 'px';
                        // e.style.top = -(hh * sx.y) + hh + 'px';
                        e.style.left = (50 * sx.x) + 50 + '%';
                        e.style.top = (-50 * sx.y) + 50 + '%';
                        e.style.visibility = 'visible';

                        raycaster.set(camera.position, dpv);

                        const intersections = raycaster.intersectObject(box);
                        const intersection = ( intersections.length ) > 0 ? intersections[ 0 ] : null;

                        if (intersection) {
                            console.log(intersection)
                            // e.style.visibility = 'visible';

                        }
                        else {
                            // e.style.visibility = 'hidden';
                        }
                    }

                    // console.log("Anchor ", pose.transform.position.x, pose.transform.position.y, pose.transform.position.z)
                }



                // Render the scene with THREE.WebGLRenderer.
                renderer.render(scene, camera)

            }
            // Queue up the next draw request.
            session.requestAnimationFrame(onXRFrame);
        };

        session.requestAnimationFrame(onXRFrame);
    }

    /** ARJS Initialization **/

    function initialize() {
        arJSScene = new THREE.Scene();

        let ambientLight = new THREE.AmbientLight(0xcccccc, 0.5);
        arJSScene.add(ambientLight);

        // arJSScamera = new THREE.OrthographicCamera(-1.0, 1.0, -1.0, 1.0, -10.0, 10.0);
        arJSScamera = new THREE.OrthographicCamera(-window.innerWidth, window.innerWidth, -window.innerHeight, window.innerHeight, -100.0, 100.0);
        arJSScene.add(arJSScamera);

        arJSSmesh = new THREE.Mesh(
            // new THREE.BoxGeometry(0.05, 0.1, 0.05),
            new THREE.BoxGeometry(50, 100, 5),
            new THREE.MeshBasicMaterial({color: 0xff0000})
        );

        mx = new THREE.Mesh(new THREE.BoxGeometry(50, 100, 5), new THREE.MeshBasicMaterial({color: 0xff0000}));
        my = new THREE.Mesh(new THREE.BoxGeometry(50, 100, 5), new THREE.MeshBasicMaterial({color: 0x00ff00}));
        mz = new THREE.Mesh(new THREE.BoxGeometry(50, 100, 5), new THREE.MeshBasicMaterial({color: 0x0000ff}));



        arJSSmesh.material.wireframe = true;
        mx.material.wireframe = true;
        my.material.wireframe = true;
        mz.material.wireframe = true;
        arJSScene.add(arJSSmesh);
        arJSScene.add(mx);
        arJSScene.add(my);
        arJSScene.add(mz);
        arJSScamera.position.z = 5;

        mx.position.x = -window.innerWidth + window.innerWidth * 0.3;
        my.position.x = -window.innerWidth + window.innerWidth * 1.01;
        mz.position.x = -window.innerWidth + window.innerWidth * 1.7;



        mx.position.y = -window.innerHeight * 0.2;
        my.position.y = -window.innerHeight * 0.2;
        mz.position.y = -window.innerHeight * 0.2;


        // handle resize
        window.addEventListener('resize', function () {
            onResize()
        });

        window.addEventListener('arjs-video-loaded', function () {
            onResize()
        });

        function onResize() {
        }


        arToolkitContext = new THREEx.ArToolkitContext({
            cameraParametersUrl: 'data/camera_para.dat',
            detectionMode: 'mono',
            canvasWidth: 80 * 6,
            canvasHeight: 60 * 6,
            maxDetectionRate: 30
        });

        arJSScamera2 = new THREE.Camera();
        arToolkitContext.init(function onCompleted() {
            arJSScamera2.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
            arjsW = arToolkitContext.arController.canvas.width;
            arjsH = arToolkitContext.arController.canvas.height;
            console.log("SIZE: W: ", arjsW, " H: ", arjsH);


            //
            let rb = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, rb);
            gl.bindFramebuffer(gl.FRAMEBUFFER, arjsBuffer2);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.RGBA8, arjsW, arjsH);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, rb);
        });

        let patternArray = ["letterA", "letterB", "letterC", "letterD", "letterF", "kanji", "hiro"];
        for (let i = 6; i < 7; i++) {
            let markerRoot = new THREE.Group();
            arJSSmarkerControls = new THREEx.ArMarkerControls(arToolkitContext, markerRoot, {
                type: 'pattern', patternUrl: "data/" + patternArray[i] + ".patt",
            });
        }
    }

    window.addEventListener("markerFound", function (e) {
    });
    window.addEventListener("markerLost", function (e) {
    });
</script>
</body>

</html>